# 03일차 - AI 슈퍼파워 앱 만들기

> **🎯 오늘의 목표**: 외부 API와 AI를 연결해서 지금까지 없던 나만의 슈퍼파워를 가진 앱을 만들어봅니다!

```table-of-contents
```

---

## 📋 오늘 완성할 프로젝트

### 프로젝트 1: 실시간 날씨 앱 🌤️
```
━━━━━━━━━━━━━━━━━━━━━━━
🌤️ 우리 동네 날씨
━━━━━━━━━━━━━━━━━━━━━━━
도시: [서울____] [확인]

┌──────┬──────┬──────┐
│ 15°C │ 13°C │ 60%  │
│ 온도  │ 체감  │ 습도  │
└──────┴──────┴──────┘

☀️ 서울 - 맑음
━━━━━━━━━━━━━━━━━━━━━━━
```

### 프로젝트 2: 나만의 AI 비서 💬
```
━━━━━━━━━━━━━━━━━━━━━━━
💬 AI 질문방
━━━━━━━━━━━━━━━━━━━━━━━

[나] 파이썬으로 뭐 할 수 있어?

[AI] 파이썬으로는 다음과 같은
     다양한 작업을 할 수 있어요:
     1. 웹 앱 개발
     2. 데이터 분석
     3. 자동화...

━━━━━━━━━━━━━━━━━━━━━━━
메시지 입력... [전송]
```

---

## 왜 이 API들을 사용하나요?

> **💡 API 선택 철학**:
> "세상 모든 API는 AI가 찾아줄 수 있어요!"
> 하지만 **왜 이 API인지** 이해하면 더 똑똑하게 원하는 서비스를 선택하고 AI와 대화할 수 있습니다.

### 🌐 오늘 사용할 주요 API

#### 1. OpenWeatherMap API - 날씨 정보

**✅ 선택 이유**:
- **무료 플랜**: 하루 1,000회 무료 (학습용 충분)
- **한글 지원**: 날씨 설명이 한국어로 제공
- **간단한 API**: JSON 응답이 직관적
- **공식 문서**: 예제 코드가 풍부

**📊 대안 비교**:

| API | 무료 플랜 | 한글 지원 | 난이도 | 추천도 |
|-----|----------|---------|--------|-------|
| **OpenWeatherMap** | 1,000회/일 | ✅ | ★☆☆ | ★★★★★ |
| Visual Crossing | 1,000회/일 | ❌ | ★★☆ | ★★★★☆ |
| WeatherAPI | 1백만회/월 | ❌ | ★☆☆ | ★★★★☆ |
| 기상청 API | 무제한 | ✅ | ★★★ | ★★★☆☆ |

**🔄 다른 날씨 API로 바꿀 수 있나요?**

**OpenWeatherMap → WeatherAPI 변경 예시**:
```python
# OpenWeatherMap 방식
response = requests.get(
    "http://api.openweathermap.org/data/2.5/weather",
    params={
        "q": "Seoul",
        "appid": api_key,
        "units": "metric"
    }
)
temp = response.json()['main']['temp']

# WeatherAPI 방식 (구조가 약간 다름)
response = requests.get(
    "http://api.weatherapi.com/v1/current.json",
    params={
        "key": api_key,
        "q": "Seoul",
        "lang": "ko"
    }
)
temp = response.json()['current']['temp_c']  # 경로가 다름!
```

**💡 핵심 차이점**:
- **URL 구조**: 각 API마다 다른 엔드포인트
- **파라미터 이름**: `appid` vs `key`, `q` vs `query`
- **응답 구조**: `['main']['temp']` vs `['current']['temp_c']`

> 💬 **AI에게 이렇게 물어보세요**:
> "OpenWeatherMap API 코드를 WeatherAPI로 바꿔줘. API KEY는 st.secrets로 관리하고, 같은 정보(온도, 습도, 날씨 설명)를 가져와야 해."

---

#### 2. OpenAI API - AI 대화 생성

**✅ 선택 이유**:
- **무료 크레딧**: 가입 시 $5 무료 제공 (학습용 충분)
- **GPT-4o-mini**: 빠르고 저렴한 모델 ($0.0001/1K 토큰)
- **간단한 사용법**: `ChatCompletion.create()` 한 줄로 대화 생성
- **풍부한 문서**: Python 라이브러리와 예제가 많음

**📊 대안 비교**:

| AI API | 무료 플랜 | 한국어 | 속도 | 비용 (1M 토큰) | 추천도 |
|--------|----------|-------|-----|-------------|-------|
| **OpenAI (GPT-4o-mini)** | $5 크레딧 | ✅ | 빠름 | $0.15/$0.60 | ★★★★★ |
| Anthropic Claude | $5 크레딧 | ✅ | 빠름 | $0.25/$1.25 | ★★★★★ |
| Google Gemini | 무료 (제한) | ✅ | 빠름 | 무료/유료 | ★★★★☆ |
| Cohere | 무료 (제한) | ✅ | 보통 | $0.15/$0.60 | ★★★☆☆ |

**🔄 다른 AI API로 바꿀 수 있나요?**

**OpenAI → Anthropic Claude 변경 예시**:
```python
# OpenAI 방식
import openai
openai.api_key = st.secrets["OPENAI_API_KEY"]

response = openai.ChatCompletion.create(
    model="gpt-4o-mini",
    messages=[
        {"role": "system", "content": "친절한 AI 비서"},
        {"role": "user", "content": "안녕?"}
    ]
)
answer = response.choices[0].message.content

# Claude 방식
import anthropic
client = anthropic.Anthropic(
    api_key=st.secrets["ANTHROPIC_API_KEY"]
)

response = client.messages.create(
    model="claude-3-haiku-20240307",
    max_tokens=1024,
    system="친절한 AI 비서",  # system은 별도 파라미터
    messages=[
        {"role": "user", "content": "안녕?"}
    ]
)
answer = response.content[0].text
```

**💡 핵심 차이점**:
- **라이브러리**: `openai` vs `anthropic`
- **system 프롬프트**: messages 안 vs 별도 파라미터
- **응답 접근**: `.choices[0].message.content` vs `.content[0].text`

**OpenAI → Google Gemini 변경 예시**:
```python
# OpenAI 방식
import openai
response = openai.ChatCompletion.create(
    model="gpt-4o-mini",
    messages=[{"role": "user", "content": "안녕?"}]
)
answer = response.choices[0].message.content

# Gemini 방식
import google.generativeai as genai
genai.configure(api_key=st.secrets["GOOGLE_API_KEY"])
model = genai.GenerativeModel('gemini-1.5-flash')

response = model.generate_content("안녕?")
answer = response.text
```

> 💬 **AI에게 이렇게 물어보세요**:
> "OpenAI GPT-4o-mini API 코드를 Claude 3 Haiku로 바꿔줘. 메시지 구조와 응답 파싱 방법이 다를 텐데, 같은 기능이 작동하도록 수정해줘."

---

### 🔄 언어와 환경 전환

**Python → Node.js 변환 예시 (날씨 API)**:

```javascript
// Python requests
import requests
response = requests.get(url, params=params)
data = response.json()

// Node.js fetch
const response = await fetch(`${url}?${new URLSearchParams(params)}`);
const data = await response.json();
```

**Python → Go 변환 예시 (OpenAI API)**:

```go
// Python
import openai
response = openai.ChatCompletion.create(model="gpt-4o-mini", messages=msgs)

// Go
import "github.com/sashabaranov/go-openai"
client := openai.NewClient(apiKey)
resp, err := client.CreateChatCompletion(ctx, openai.ChatCompletionRequest{
    Model: openai.GPT4oMini,
    Messages: msgs,
})
```

> 💡 **핵심**: 언어가 바뀌어도 API 개념은 같습니다!
> - HTTP 요청 보내기 (GET/POST)
> - JSON 응답 파싱하기
> - 에러 처리하기

---

### 🎯 실전 상황별 API 선택

#### 상황 1: 날씨 앱이 너무 느려요

**원인**: OpenWeatherMap 무료 플랜의 속도 제한

**해결책**:
```python
# 방법 1: 캐싱으로 불필요한 요청 줄이기
import time

if 'last_update' not in st.session_state or \
   time.time() - st.session_state.last_update > 600:  # 10분마다만 갱신
    response = requests.get(url, params=params)
    st.session_state.weather_data = response.json()
    st.session_state.last_update = time.time()

data = st.session_state.weather_data

# 방법 2: 더 빠른 API로 변경 (WeatherAPI)
# 또는 국내 기상청 API 사용
```

#### 상황 2: OpenAI 비용이 너무 많이 나와요

**원인**: 대화 히스토리가 계속 쌓여서 토큰 소모 증가

**해결책**:
```python
# 방법 1: 최근 N개 메시지만 유지
MAX_MESSAGES = 10
if len(st.session_state.messages) > MAX_MESSAGES:
    # system 메시지는 유지, 나머지는 최근 10개만
    st.session_state.messages = [
        st.session_state.messages[0]  # system
    ] + st.session_state.messages[-MAX_MESSAGES:]

# 방법 2: 더 저렴한 모델 사용
# gpt-4o-mini 대신 claude-3-haiku (더 저렴)

# 방법 3: 무료 API로 변경 (Google Gemini)
import google.generativeai as genai
model = genai.GenerativeModel('gemini-1.5-flash')  # 무료!
```

#### 상황 3: AI 응답이 너무 느려요

**원인**: GPT-4 같은 큰 모델 사용

**해결책**:
```python
# 방법 1: 더 빠른 모델 사용
response = openai.ChatCompletion.create(
    model="gpt-4o-mini",  # gpt-4 대신 mini 사용 (10배 빠름)
    messages=messages
)

# 방법 2: streaming으로 실시간 표시
response = openai.ChatCompletion.create(
    model="gpt-4o-mini",
    messages=messages,
    stream=True  # 실시간으로 받기
)

for chunk in response:
    if chunk.choices[0].delta.content:
        st.write(chunk.choices[0].delta.content, end="")
```

---

### 💡 핵심 정리

**API 선택 철학**:
1. **무료 플랜부터 시작**: 학습 단계에서는 무료 플랜으로 충분
2. **문서가 좋은 것 선택**: 예제 코드가 많을수록 AI가 더 정확한 코드 생성
3. **한국어 지원 확인**: 한글 데이터가 필요하면 한글 지원 API 선택
4. **비용 고려**: 실제 서비스는 비용 계산 후 선택

**AI를 활용한 API 전환**:
```
"현재 [A API] 코드를 [B API]로 바꾸고 싶어.
두 API의 차이점과 변경이 필요한 부분을 알려주고,
전체 코드를 [B API] 방식으로 다시 작성해줘."
```

**다음 단계**:
- OpenWeatherMap으로 시작 → 익숙해지면 다른 날씨 API 시도
- OpenAI로 시작 → Claude, Gemini 등 다른 AI 비교
- Python으로 시작 → Node.js, Go 등 다른 언어로 확장

---

## 🕐 09:00-09:30 어제 복습

<details>
<summary><strong>퀴즈 1: 파일 저장 코드</strong></summary>

**질문**: 메모를 파일로 저장하는 코드는?

```python
# 정답
with open("파일명.txt", "w") as file:
    file.write(내용)
```
</details>

<details>
<summary><strong>퀴즈 2: 세션 상태</strong></summary>

**질문**: Streamlit에서 데이터를 계속 저장하려면?

```python
# 정답
if 'todos' not in st.session_state:
    st.session_state.todos = []

st.session_state.todos.append(새할일)
```
</details>

<details>
<summary><strong>퀴즈 3: 딕셔너리</strong></summary>

**질문**: 할일과 완료여부를 저장하는 딕셔너리는?

```python
# 정답
todo = {
    "task": "할 일 내용",
    "completed": False
}
```
</details>

---

## 🕐 09:30-12:00 프로젝트 1: 실시간 날씨 앱

### 📱 완성 미리보기

```
━━━━━━━━━━━━━━━━━━━━━━━
🌤️ 우리 동네 날씨
━━━━━━━━━━━━━━━━━━━━━━━
도시: [서울____] [날씨 확인]

━━━━━━━━━━━━━━━━━━━━━━━
┌──────┬──────┬──────┐
│ 15°C │ 13°C │ 60%  │
│ 온도  │ 체감  │ 습도  │
└──────┴──────┴──────┘

☀️ 서울 - 맑음
━━━━━━━━━━━━━━━━━━━━━━━
```

---

### Step 1: AI에게 날씨 앱 요청하기 (30분)

#### 🗂️ day3 폴더 준비

**폴더 구조**:
```
C:\Work\abc-bootcamp-202510\
├── day1\
├── day2\
└── day3\           ← 오늘 작업 폴더
    └── weather_app.py
```

1. VSCode Explorer에서 `day3` 폴더 생성
2. `day3` 폴더에 `weather_app.py` 파일 생성

#### 📝 AI 프롬프트

```
Streamlit으로 날씨 정보 앱을 만들어줘.

요구사항:
1. 도시 이름을 입력받는다
2. "날씨 확인" 버튼이 있다
3. OpenWeatherMap API를 사용한다
4. 온도, 체감온도, 습도를 3개 컬럼으로 보여준다
5. 날씨 설명도 표시한다

파일명: weather_app.py

추가 조건:
- API KEY는 Streamlit secrets로 관리
- 에러 처리 포함
- 이모지 사용해서 예쁘게
```

#### 🔑 API KEY 발급 방법

**OpenWeatherMap 가입**:
1. https://openweathermap.org/ 접속
2. 회원가입 (무료)
3. API Keys 메뉴에서 KEY 복사

**Streamlit Secrets 설정**:

1. **day3 폴더에 .streamlit 폴더 생성**:
   ```
   C:\Work\abc-bootcamp-202510\day3\
   ├── .streamlit\         ← 새로 만들기
   │   └── secrets.toml
   └── weather_app.py
   ```

2. **Windows 명령 프롬프트** (또는 VSCode 터미널):
   ```bash
   cd C:\Work\abc-bootcamp-202510\day3
   mkdir .streamlit
   ```

3. **VSCode에서 secrets.toml 파일 생성**:
   - `.streamlit` 폴더에 `secrets.toml` 파일 생성
   - 다음 내용 입력:
   ```toml
   OPENWEATHER_API_KEY = "여기에_복사한_키_붙여넣기"
   ```

> ⚠️ **주의**: `.streamlit` 폴더는 절대 GitHub에 올리지 마세요!

#### ▶️ 실행하기

```bash
streamlit run weather_app.py
```

**브라우저에서 확인**: http://localhost:8501

---

### Step 2: 코드 이해하기 (30분)

#### 🔍 핵심 코드 분석

```python
import streamlit as st
import requests

# Streamlit secrets에서 API KEY 가져오기
api_key = st.secrets["OPENWEATHER_API_KEY"]

# API 요청 보내기
url = "http://api.openweathermap.org/data/2.5/weather"
params = {
    "q": city,           # 도시 이름
    "appid": api_key,    # API 키
    "units": "metric",   # 섭씨 온도
    "lang": "kr"         # 한국어
}

response = requests.get(url, params=params)
data = response.json()  # JSON → 딕셔너리 변환
```

#### 💡 새로운 개념

**1. requests 라이브러리**
```python
import requests

# GET 요청: 데이터 조회
response = requests.get(url, params=params)

# 응답 상태 코드
print(response.status_code)  # 200: 성공, 404: 없음

# JSON 데이터 가져오기
data = response.json()
```

**2. API란?**
- **A**pplication **P**rogramming **I**nterface
- 다른 서비스의 데이터를 가져오는 방법
- 예: 날씨 정보, 지도 정보, 번역 등

**3. st.secrets**
```python
# 비밀 정보 안전하게 관리
api_key = st.secrets["KEY_NAME"]
```

**4. try-except (에러 처리)**
```python
try:
    # 시도할 코드
    response = requests.get(url)
    data = response.json()
except:
    # 에러 발생 시 실행
    st.error("날씨를 가져올 수 없습니다")
```

---

### 🎯 나의 언어로 정리하기 (파인만 기법)

> **왜 이 방법이 중요한가?**: API는 "다른 서비스의 데이터를 가져오는 마법"처럼 느껴집니다.
> 하지만 정확히 어떻게 작동하는지 내 언어로 설명할 수 있어야 실전에서 자유롭게 활용할 수 있습니다!

#### 📝 실습: API 작동 원리 설명해보기

**Step 1: 나만의 방식으로 써보기** (5분)

친구에게 설명한다고 생각하고 써보세요:
```
API가 어떻게 작동하는지 내가 이해한 내용:

"requests.get()으로 URL에 요청을 보내면..."
"response.status_code는..."
"response.json()은..."

✍️ [여기에 자유롭게 작성]
```

**Step 2: AI와 검증하기** (5-10분)

💬 AI에게 이렇게 질문:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
API 작동 원리에 대해 내가 이해한 내용이야:

"[위에서 작성한 내용을 여기에 복사-붙여넣기]"

이 설명이 정확해? 틀린 부분이나 빠진 개념 있어?
일상생활 비유로도 설명해줘.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**Step 3: 수정하고 재정리** (3분)

AI 피드백을 반영해서 다시 써보세요:
```
[수정된 설명]
```

---

#### 🎯 즉시 미션

다음 중 하나를 선택해서 "나의 언어로 설명하기":

**옵션 A**: `response.status_code == 200`이 왜 중요한지
```
내 설명: "status_code는..."
```

**옵션 B**: `response.json()`이 하는 일
```
내 설명: "json()은 API 응답을..."
```

**옵션 C**: `st.secrets`를 사용하는 이유
```
내 설명: "API KEY를 secrets에 넣는 이유는..."
```

**옵션 D**: try-except가 필요한 상황
```
내 설명: "API 요청이 실패할 수 있어서..."
```

---

#### 💡 학습 효과 비교

| 방법 | API 이해도 | 실전 활용력 | 문제 해결력 |
|------|-----------|------------|-----------|
| 그냥 코드 복사하기 | 20% | 거의 없음 | 낮음 |
| 코드 실행하고 결과 보기 | 50% | 낮음 | 보통 |
| **나의 언어로 정리** | 85% | 매우 높음 | 높음 |

> 💡 **실전 팁**: API 에러가 나면 "어느 단계에서 문제가 생겼는지"를 설명해보세요.
> - requests.get()에서? → URL이나 params 문제
> - response.status_code가 200이 아니면? → API KEY나 도시명 문제
> - response.json()에서? → 응답 형식 문제
>
> 내가 이해한 것을 설명하다 보면 문제가 어디인지 자연스럽게 발견됩니다!

---

### 🔍 Step 3: 디버깅으로 API 응답 이해하기 (20분)

#### API 응답 구조 들여다보기

**디버깅 코드 추가**:
```python
import streamlit as st
import requests

st.title("🌤️ 우리 동네 날씨")

city = st.text_input("도시", value="Seoul")

if st.button("날씨 확인"):
    url = "http://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city,
        "appid": st.secrets["OPENWEATHER_API_KEY"],
        "units": "metric",
        "lang": "kr"
    }

    response = requests.get(url, params=params)

    # 🔍 디버깅: 응답 상태 확인
    st.write(f"🔍 응답 코드: {response.status_code}")
    st.write(f"🔍 성공? {response.status_code == 200}")

    if response.status_code == 200:
        data = response.json()

        # 🔍 디버깅: 전체 데이터 구조 확인
        st.write("🔍 전체 응답 데이터:")
        st.json(data)  # JSON을 예쁘게 표시

        # 🔍 디버깅: 특정 값 추출 과정
        st.write(f"🔍 data['main'] = {data['main']}")
        st.write(f"🔍 data['main']['temp'] = {data['main']['temp']}")
        st.write(f"🔍 data['weather'] = {data['weather']}")
        st.write(f"🔍 data['weather'][0] = {data['weather'][0]}")
        st.write(f"🔍 날씨 설명 = {data['weather'][0]['description']}")
```

**실행해보고 관찰하기**:
1. `data` 딕셔너리 구조는 어떻게 생겼나요?
2. 온도는 어디에 숨어있나요? (`data['main']['temp']`)
3. 날씨 설명은? (`data['weather'][0]['description']`)
4. 다른 도시로 검색하면 구조가 같나요?

---

#### 실습 과제: 에러 응답 디버깅

**버그가 있는 코드**:
```python
# 🐛 버그: 에러 처리 없음
response = requests.get(url, params=params)
data = response.json()

# 도시명이 틀리면 여기서 에러!
temp = data['main']['temp']
```

**미션**:
1. 존재하지 않는 도시명 입력 ("asdfasdf")
2. 어떤 에러가 발생하나요?
3. `response.status_code`는 몇인가요?
4. 에러 처리 추가하기

<details>
<summary>💡 힌트</summary>

```python
response = requests.get(url, params=params)

# 🔍 디버깅
st.write(f"🔍 응답 코드: {response.status_code}")

if response.status_code == 200:
    data = response.json()
    temp = data['main']['temp']
    st.write(f"온도: {temp}°C")
elif response.status_code == 404:
    st.error("도시를 찾을 수 없습니다")
else:
    st.error(f"에러 발생: {response.status_code}")

# 응답 코드 의미:
# 200 = 성공
# 404 = 찾을 수 없음
# 401 = 인증 실패 (API KEY 문제)
# 500 = 서버 에러
```
</details>

---

#### JSON 데이터 구조 이해하기

**딕셔너리 접근 디버깅**:
```python
# API 응답 예시 구조
data = {
    "main": {
        "temp": 15.5,
        "feels_like": 13.2,
        "humidity": 60
    },
    "weather": [
        {
            "description": "맑음",
            "icon": "01d"
        }
    ]
}

# 🔍 접근 방법
st.write("### 딕셔너리 접근 연습")
st.write(f"1단계: data['main'] = {data['main']}")
st.write(f"2단계: data['main']['temp'] = {data['main']['temp']}")
st.write(f"리스트: data['weather'] = {data['weather']}")
st.write(f"첫 번째 항목: data['weather'][0] = {data['weather'][0]}")
st.write(f"설명: data['weather'][0]['description'] = {data['weather'][0]['description']}")
```

---

### Step 4: AI 답변 비교하고 선별하기 (20분)

> **핵심**: AI가 만든 코드를 무비판적으로 받아들이지 말고, 비교하고 선택하는 능력을 키우자!

#### 🔍 실습: 같은 질문, 다른 프롬프트, 다른 결과

**미션 1: 날씨 앱 코드를 3가지 방식으로 요청**

**프롬프트 A (간단)**:
```
"날씨 앱 만들어줘"
```

**프롬프트 B (구체적)**:
```
"Streamlit으로 도시 입력받아서 OpenWeatherMap API로
온도, 습도, 날씨를 보여주는 앱을 만들어줘"
```

**프롬프트 C (초구체적)**:
```
"Streamlit으로 날씨 앱을 만들어줘.

요구사항:
1. st.text_input으로 도시명 입력
2. OpenWeatherMap API 사용 (st.secrets로 API KEY 관리)
3. 온도, 체감온도, 습도를 3열 컬럼으로 표시
4. 에러 처리 포함 (도시를 찾을 수 없는 경우)
5. 이모지 사용해서 시각적으로 표시
```

---

#### 🎯 비교 분석하기

**질문**:
```
1. 어떤 프롬프트가 더 나은 코드를 만들었나요?

2. 세 코드의 차이점은 무엇인가요?
   A: _________________________
   B: _________________________
   C: _________________________

3. 각 코드의 장단점은?
   A 장점: ____________________
   A 단점: ____________________

   B 장점: ____________________
   B 단점: ____________________

   C 장점: ____________________
   C 단점: ____________________

4. 실제로 사용하려면 어떤 코드를 선택할 건가요?
```

---

#### 💡 배울 점

**✅ 좋은 프롬프트 = 좋은 결과**
```
구체적일수록 → 원하는 결과에 가까워짐
요구사항이 명확할수록 → 수정할 부분이 줄어듦
```

**✅ 여러 답변 비교의 중요성**
```
첫 번째 답변이 최선은 아닐 수 있음
같은 질문을 다르게 해보기
여러 답변 중 최선 선택하기
```

**✅ "이게 왜 더 나은가?" 판단 기준 생기기**
```
- 코드가 읽기 쉬운가?
- 에러 처리가 잘 되어 있나?
- 사용자 경험이 좋은가?
- 확장하기 쉬운가?
```

---

#### 🐛 실습: AI 코드의 문제점 찾기

**AI가 만든 코드 (문제 있음)**:
```python
# 🐛 버그가 숨어있는 코드
import streamlit as st
import requests

url = "http://api.openweathermap.org/data/2.5/weather"
city = st.text_input("도시")

if st.button("확인"):
    response = requests.get(url, params={"q": city, "appid": "YOUR_KEY"})
    temp = response.json()['main']['temp']  # 🐛 여기!
    st.write(f"온도: {temp}")
```

**질문**:
```
1. 어떤 상황에서 문제가 생길까요?
   □ API 키가 틀릴 때
   □ 도시명이 틀릴 때
   □ 인터넷이 끊겼을 때
   □ 위 모두

2. 어떻게 고치면 좋을까요?

3. AI에게 "이 코드의 문제점을 찾아줘" 질문해보기
```

<details>
<summary>💡 정답 및 개선 코드</summary>

**문제점**:
```
1. API 키가 하드코딩됨 (보안 문제)
2. 응답 코드 확인 안 함 (에러 처리 없음)
3. 도시명이 비어있어도 요청 보냄
4. KeyError 발생 가능
```

**개선 코드**:
```python
import streamlit as st
import requests

url = "http://api.openweathermap.org/data/2.5/weather"
city = st.text_input("도시")

if st.button("확인"):
    if not city:
        st.warning("도시명을 입력하세요")
    else:
        try:
            response = requests.get(url, params={
                "q": city,
                "appid": st.secrets["OPENWEATHER_API_KEY"],  # ✅ secrets 사용
                "units": "metric"
            })

            if response.status_code == 200:  # ✅ 응답 확인
                data = response.json()
                temp = data.get('main', {}).get('temp')  # ✅ 안전한 접근

                if temp:
                    st.write(f"온도: {temp}°C")
                else:
                    st.error("온도 정보를 찾을 수 없습니다")
            else:
                st.error(f"에러: {response.status_code}")

        except Exception as e:
            st.error(f"예상치 못한 오류: {e}")
```
</details>

---

#### ✅ 선별 능력 체크리스트

**질문**:
- [ ] AI에게 여러 방식으로 질문해봤나요?
- [ ] 여러 답변을 비교했나요?
- [ ] 왜 이 코드가 더 나은지 설명할 수 있나요?
- [ ] AI 코드의 문제점을 찾아낼 수 있나요?

**중요**:
```
💡 AI는 강력한 도구지만,
   좋은 질문과 좋은 선택은
   여러분의 몫입니다!
```

---

#### 🎯 AI 코드, 제대로 활용하기

> **핵심**: AI는 강력한 조수이지만, 최종 선택은 **여러분의 몫**입니다.

**AI와 나의 역할 구분**:

| AI가 하는 것 | 여러분이 하는 것 |
|------------|---------------|
| 빠르게 코드 생성 | 코드 이해하기 |
| 여러 방법 제시 | 최선의 방법 선택 |
| 초안 만들기 | 검증하고 개선하기 |

---

##### 📋 AI 코드 검증 체크리스트

**받자마자 (30초)**:
- [ ] 코드를 천천히 읽어봤나요?
- [ ] 모르는 부분을 표시했나요?

**실행 전에 (1분)**:
- [ ] 어떤 라이브러리가 필요한가요?
- [ ] 설치가 필요한 게 있나요?

**실행 후에 (3분)**:
- [ ] 정상적으로 작동하나요?
- [ ] 에러가 발생하지 않나요?
- [ ] 예상한 결과가 나왔나요?

**최종 확인 (5분)**:
- [ ] 코드를 한 줄씩 설명할 수 있나요?
- [ ] 왜 이 방법을 사용했는지 아나요?
- [ ] 다른 사람에게 가르쳐줄 수 있나요?

---

##### 🚨 AI가 자주 하는 실수

```python
# 1. 없는 기능 사용
streamlit.beta_columns()  # 구 버전 함수

# 2. 에러 처리 누락
data['key']  # KeyError 발생 가능!

# 3. 하드코딩
api_key = "sk-abc123"  # 보안 위험!
```

> 💡 **기억하세요**: AI는 그럴듯하지만 틀린 답을 자신있게 말할 수 있습니다.
> 코드를 이해하고 검증하는 능력, 그게 **여러분의 진짜 실력**입니다! 💪

---

### Step 5: 바이브코딩 잘하는 3가지 법칙 (20분)

> **핵심**: "AI에게 실망하는 이유 = 내가 원하는 걸 AI가 몰라서"

#### 📋 법칙 1: 내가 원하는 결과를 먼저 말로 설명하기

**질문**: 지금 무엇을 만들고 싶나요?

❌ **나쁜 예**:
```
"날씨 앱 만들어줘"
→ AI가 알아서 만들어주겠지? (기대값 없음)
```

✅ **좋은 예**:
```
"도시 이름 입력하면 → 온도랑 날씨 아이콘 보여주는 앱"
→ 내가 뭘 보고 싶은지 명확함
```

**실습 (5분)**:
```
다음 중 원하는 앱을 골라서, "무엇이 → 어떻게 되는" 형태로 설명해보세요:

1. 영어 단어장 앱
2. D-day 계산기
3. 간단한 메모장

✍️ [내 설명 작성하기]
예: "단어 입력 → 뜻이랑 예문이 나오고 → 저장 버튼 누르면 목록에 추가"
```

---

#### 🎯 법칙 2: 구체적으로, 길게, 명확하게

**핵심**: 모호한 말 = 모호한 결과

❌ **나쁜 예**:
```
"그거 색깔 바꿔줘"
- 그거 = 뭐?
- 색깔 = 무슨 색?
```

✅ **좋은 예**:
```
"`st.title()` 글자 색을 파란색으로 바꿔줘.
CSS로 `color: blue` 스타일 적용해줘."

- 무엇을: st.title()
- 어떻게: 파란색
- 방법까지: CSS
```

**실습 (10분)**:
```
다음 애매한 요청을 구체적으로 바꿔보세요:

❌ "이미지 크게 해줘"
✅ "____________________________"

❌ "버튼 이쁘게 만들어"
✅ "____________________________"

❌ "에러 좀 고쳐줘"
✅ "____________________________"

힌트:
- 무엇을 (변수명/함수명)
- 어떻게 (구체적 값)
- 어디서 (파일명/줄 번호)
```

<details>
<summary>💡 예시 답안</summary>

```
✅ "st.image()의 width 파라미터를 400으로 설정해줘"

✅ "날씨 확인 버튼을 파란색 배경에 흰색 글씨로 변경하고,
    st.button('날씨 확인', type='primary')를 사용해줘"

✅ "weather_app.py 37줄에서 발생하는 KeyError를
    try-except로 감싸서 '도시를 찾을 수 없습니다' 메시지를 표시해줘"
```
</details>

---

#### 🔍 법칙 3: 큰 변경은 "계획 먼저, 실행 나중에"

**비유**: 집 리모델링할 때 설계도 먼저 보잖아요?

**2단계 요청 패턴**:

**1단계: 계획 물어보기**
```
❌ 바로 요청:
"날씨 앱에 지도 기능 추가해줘"

✅ 계획 먼저:
"날씨 앱에 지도 기능 추가하려면 어떤 단계가 필요해?
어떤 라이브러리가 필요하고, 코드는 어느 부분을 수정해야 해?"
```

**2단계: 계획 확인 후 실행**
```
[AI 답변 확인]
"folium 라이브러리 설치 → 지도 생성 코드 → st.components로 표시"

→ 이해됨? OK, 진행!
→ 이해 안 됨? 다시 질문!

"좋아, 그럼 그 계획대로 코드 작성해줘."
```

**실습 (5분)**:
```
다음 요청을 2단계로 나눠보세요:

"QR 코드 앱에 로고 이미지 넣고 싶어"

1단계 (계획):
"____________________________"

2단계 (실행):
"____________________________"
```

<details>
<summary>💡 예시 답안</summary>

```
1단계 (계획):
"QR 코드에 로고 이미지를 넣으려면 어떤 방법이 있어?
필요한 라이브러리와 코드 수정 범위를 알려줘."

2단계 (실행):
[계획 확인 후]
"PIL 라이브러리로 QR 코드 중앙에 로고를 합성하는 코드를 작성해줘.
로고 크기는 QR 코드의 1/5 정도로 하고, 투명도는 유지해줘."
```
</details>

---

#### 📊 체크리스트: 내 프롬프트 점수는?

**프롬프트 작성 전 자가진단**:

```
□ 내가 원하는 결과를 한 문장으로 설명할 수 있는가?
□ "이거, 그거, 저거" 같은 대명사를 안 썼는가?
□ 변수명/함수명을 정확히 썼는가?
□ 큰 변경이면 "계획 먼저" 물어봤는가?

✅ 4개 체크 = 만족도 90% 프롬프트!
```

**프롬프트 개선 전후 비교**:

| 개선 전 (❌) | 개선 후 (✅) | 만족도 |
|------------|------------|-------|
| "날씨 앱 만들어줘" | "Streamlit으로 도시 입력받아서 OpenWeatherMap API로 온도, 습도, 날씨를 표시하는 앱" | ⭐⭐⭐⭐⭐ |
| "이미지 좀 크게" | "`st.image()`의 `width` 파라미터를 400으로 설정해줘" | ⭐⭐⭐⭐⭐ |
| "에러 고쳐줘" | "weather_app.py 37줄의 KeyError를 try-except로 처리하고 '도시를 찾을 수 없습니다' 메시지 표시해줘" | ⭐⭐⭐⭐⭐ |
| "기능 추가해줘" | "먼저 이 기능을 추가하려면 어떤 단계가 필요한지 알려줘" | ⭐⭐⭐⭐⭐ |

---

#### 💡 핵심 정리

**바이브코딩 만족도 90%의 비결**:

1. **기대값을 명확히** → "무엇이 어떻게 되는" 형태로 설명
2. **구체적으로 요청** → 변수명, 함수명, 값까지 정확히
3. **단계적으로 진행** → 계획 확인 → 실행

**기억하세요**:
```
🎯 AI는 여러분의 마음을 읽지 못합니다
🎯 구체적일수록 원하는 결과가 나옵니다
🎯 큰 변경은 계획부터 확인하세요
```

---

### Step 6: 직접 수정해보기 (1시간)

#### ✏️ 도전 과제 1: 날씨에 따른 이모지

**AI에게 요청**:
```
날씨 상태에 따라 다른 이모지를 보여주는 기능을 추가해줘.

- 맑음: ☀️
- 흐림: ☁️
- 비: 🌧️
- 눈: ❄️
```

#### ✏️ 도전 과제 2: 여러 도시 비교

**AI에게 요청**:
```
여러 도시의 날씨를 동시에 비교하는 기능을 추가해줘.

요구사항:
- 도시를 여러 개 입력받는다 (쉼표로 구분)
- 각 도시의 온도를 표로 보여준다
- 가장 따뜻한/추운 도시를 강조한다
```

#### ✏️ 도전 과제 3: 5일 예보

**AI에게 요청**:
```
5일간의 날씨 예보를 보여주는 기능을 추가해줘.

OpenWeatherMap의 5 day forecast API를 사용.
날짜별로 최고/최저 온도를 차트로 보여줘.
```

<details>
<summary><strong>💡 힌트: API 엔드포인트</strong></summary>

```python
# 5일 예보 API
url = "http://api.openweathermap.org/data/2.5/forecast"

# 차트 그리기
import pandas as pd

df = pd.DataFrame({
    "날짜": ["1/10", "1/11", "1/12"],
    "온도": [15, 13, 14]
})

st.line_chart(df.set_index("날짜"))
```
</details>

---

## 🕐 13:00-16:30 프로젝트 2: 나만의 AI 비서

### 📱 완성 미리보기

```
━━━━━━━━━━━━━━━━━━━━━━━
💬 AI 질문방
━━━━━━━━━━━━━━━━━━━━━━━

[나] 안녕?

[AI] 안녕하세요! 무엇을
     도와드릴까요? 😊

[나] 파이썬으로 뭐 할 수 있어?

[AI] 파이썬으로는:
     1. 웹 앱 개발
     2. 데이터 분석
     3. AI/머신러닝
     4. 자동화...

━━━━━━━━━━━━━━━━━━━━━━━
메시지 입력... [전송]
```

---

### Step 1: AI에게 챗봇 요청하기 (40분)

#### 🗂️ chatbot_app.py 파일 생성

**day3 폴더에 추가**:
```
C:\Work\abc-bootcamp-202510\day3\
├── .streamlit\
│   └── secrets.toml
├── weather_app.py
└── chatbot_app.py    ← 새로 만들기
```

#### 📝 AI 프롬프트

```
Streamlit으로 AI 챗봇을 만들어줘.

요구사항:
1. OpenAI GPT-3.5-turbo API 사용
2. Streamlit의 chat_message, chat_input 사용
3. 대화 히스토리를 세션 상태로 관리
4. 사이드바에 "대화 초기화" 버튼
5. API KEY는 Streamlit secrets로 관리

파일명: chatbot_app.py

추가 조건:
- 시스템 프롬프트: "친절한 AI 비서"
- 에러 처리 포함
- 로딩 중 스피너 표시
```

#### 🔑 API KEY 발급 방법

**OpenAI 가입**:
1. https://platform.openai.com/ 접속
2. 회원가입 ($5 무료 크레딧)
3. API Keys 생성 및 복사

**Secrets 파일에 추가**:

**day3/.streamlit/secrets.toml 파일 수정**:
```toml
# 기존 키
OPENWEATHER_API_KEY = "기존_키"

# OpenAI 키 추가
OPENAI_API_KEY = "sk-여기에_OpenAI_키_붙여넣기"
```

> 💡 **같은 secrets.toml 파일에 여러 API KEY를 함께 관리합니다**

#### ▶️ 실행하기

```bash
# 필요한 라이브러리 설치
pip install openai

streamlit run chatbot_app.py
```

---

### Step 2: 코드 이해하기 (30분)

#### 🔍 핵심 코드 분석

```python
import openai

# API KEY 설정
openai.api_key = st.secrets["OPENAI_API_KEY"]

# 대화 메시지 구조
messages = [
    {"role": "system", "content": "당신은 친절한 AI 비서입니다."},
    {"role": "user", "content": "안녕?"},
    {"role": "assistant", "content": "안녕하세요!"}
]

# AI 응답 생성
response = openai.ChatCompletion.create(
    model="gpt-4o-mini",
    messages=messages
)

answer = response.choices[0].message.content
```

#### 💡 새로운 개념

**1. OpenAI API 메시지 구조**
```python
# system: AI의 성격/역할 설정
{"role": "system", "content": "당신은 친절한 선생님입니다."}

# user: 사용자 메시지
{"role": "user", "content": "파이썬이 뭐야?"}

# assistant: AI 응답
{"role": "assistant", "content": "파이썬은..."}
```

**2. st.chat_message()**
```python
# 사용자 메시지 표시
with st.chat_message("user"):
    st.write("안녕?")

# AI 메시지 표시
with st.chat_message("assistant"):
    st.write("안녕하세요!")
```

**3. st.chat_input()**
```python
# 채팅 입력창
user_input = st.chat_input("메시지를 입력하세요...")

if user_input:
    # 입력된 메시지 처리
    print(user_input)
```

**4. 대화 히스토리 관리**
```python
# 세션 상태에 대화 저장
if 'messages' not in st.session_state:
    st.session_state.messages = []

# 메시지 추가
st.session_state.messages.append({
    "role": "user",
    "content": user_input
})

# 모든 대화 표시
for msg in st.session_state.messages:
    with st.chat_message(msg["role"]):
        st.write(msg["content"])
```

---

### 🎯 나의 언어로 정리하기 (파인만 기법)

> **왜 이 방법이 중요한가?**: AI 챗봇의 메시지 구조는 단순해 보이지만, 정확히 이해하지 못하면 대화가 꼬이거나 AI가 이전 맥락을 잊어버립니다.
> 내 언어로 설명할 수 있어야 문제가 생겼을 때 스스로 해결할 수 있습니다!

#### 📝 실습: AI 메시지 구조 설명해보기

**Step 1: 나만의 방식으로 써보기** (5분)

친구에게 설명한다고 생각하고 써보세요:
```
OpenAI API 메시지 구조가 어떻게 작동하는지 내가 이해한 내용:

"messages 배열에는..."
"system role은..."
"user와 assistant role은..."
"AI가 대화를 기억하는 방법은..."

✍️ [여기에 자유롭게 작성]
```

**Step 2: AI와 검증하기** (5-10분)

💬 AI에게 이렇게 질문:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
OpenAI API 메시지 구조에 대해 내가 이해한 내용이야:

"[위에서 작성한 내용을 여기에 복사-붙여넣기]"

이 설명이 정확해? 틀린 부분이나 빠진 개념 있어?
채팅앱이 대화를 기억하는 원리를 비유로도 설명해줘.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**Step 3: 수정하고 재정리** (3분)

AI 피드백을 반영해서 다시 써보세요:
```
[수정된 설명]
```

---

#### 🎯 즉시 미션

다음 중 하나를 선택해서 "나의 언어로 설명하기":

**옵션 A**: `system` role이 하는 역할
```
내 설명: "system role은 AI의..."
```

**옵션 B**: messages 배열이 커지면 문제가 되는 이유
```
내 설명: "배열이 커지면 토큰이..."
```

**옵션 C**: `st.session_state.messages`가 필요한 이유
```
내 설명: "세션 상태가 없으면..."
```

**옵션 D**: AI가 이전 대화를 기억하는 원리
```
내 설명: "AI는 messages 배열 전체를..."
```

---

#### 💡 학습 효과 비교

| 방법 | 메시지 구조 이해도 | 문제 해결력 | 실전 활용력 |
|------|------------------|-----------|-----------|
| 그냥 코드 복사하기 | 20% | 거의 없음 | 낮음 |
| 코드 실행하고 결과 보기 | 50% | 낮음 | 보통 |
| **나의 언어로 정리** | 85% | 매우 높음 | 높음 |

> 💡 **실전 팁**: 챗봇 문제가 생기면 "messages 배열이 어떻게 쌓였는지"를 설명해보세요.
> - AI가 대화를 잊어버림? → system 메시지 확인, 배열 길이 확인
> - 비용이 너무 많이 나옴? → 배열에 쌓인 토큰 수 확인
> - 대화가 꼬임? → role 순서가 올바른지 확인
>
> 내가 이해한 것을 설명하다 보면 문제가 어디인지 자연스럽게 발견됩니다!

---

### 🔍 Step 3: 디버깅으로 AI 대화 이해하기 (20분)

#### 대화 메시지 구조 들여다보기

**디버깅 코드 추가**:
```python
import streamlit as st
import openai

openai.api_key = st.secrets["OPENAI_API_KEY"]

st.title("💬 AI 질문방")

# 세션 상태 초기화
if 'messages' not in st.session_state:
    st.session_state.messages = [
        {"role": "system", "content": "당신은 친절한 AI 비서입니다."}
    ]

# 🔍 디버깅: 전체 메시지 구조 확인
with st.expander("🔍 DEBUG: 메시지 히스토리"):
    st.write(f"총 메시지 수: {len(st.session_state.messages)}개")
    for i, msg in enumerate(st.session_state.messages):
        st.write(f"[{i}] {msg['role']}: {msg['content'][:50]}...")

# 채팅 입력
user_input = st.chat_input("메시지 입력...")

if user_input:
    # 🔍 디버깅: 사용자 메시지 추가 전후
    st.write(f"🔍 추가 전 메시지 수: {len(st.session_state.messages)}")

    st.session_state.messages.append({
        "role": "user",
        "content": user_input
    })

    st.write(f"🔍 추가 후 메시지 수: {len(st.session_state.messages)}")
    st.write(f"🔍 마지막 메시지: {st.session_state.messages[-1]}")

    # AI 응답 생성
    response = openai.ChatCompletion.create(
        model="gpt-4o-mini",
        messages=st.session_state.messages
    )

    # 🔍 디버깅: AI 응답 구조
    st.write("🔍 AI 응답 전체:")
    st.json(response)

    ai_message = response.choices[0].message.content

    st.write(f"🔍 추출한 답변: {ai_message}")

    st.session_state.messages.append({
        "role": "assistant",
        "content": ai_message
    })
```

**실행해보고 관찰하기**:
1. `messages` 리스트에는 어떤 순서로 쌓이나요?
2. system 메시지는 어디에 있나요?
3. AI는 이전 대화를 어떻게 기억하나요?
4. `response` 객체에는 어떤 정보가 있나요?

---

#### 실습 과제: 대화 컨텍스트 디버깅

**미션**:
```python
# 🔍 이 코드가 왜 대화를 기억하는지 확인하기

# 1번 질문: "내 이름은 철수야"
# 2번 질문: "내 이름이 뭐였지?"

# 디버깅: messages 배열 확인
st.write("🔍 AI에게 전달되는 메시지:")
for msg in st.session_state.messages:
    if msg["role"] != "system":
        st.write(f"- {msg['role']}: {msg['content']}")
```

<details>
<summary>💡 힌트</summary>

```python
# AI는 messages 배열 전체를 받음
messages = [
    {"role": "system", "content": "친절한 AI"},
    {"role": "user", "content": "내 이름은 철수야"},
    {"role": "assistant", "content": "안녕하세요 철수님!"},
    {"role": "user", "content": "내 이름이 뭐였지?"},  # ← 새 질문
]

# AI는 위 전체 대화를 보고 답변
# 그래서 "철수"라는 이름을 기억할 수 있음!
```
</details>

---

#### 토큰과 비용 이해하기

**토큰 계산 디버깅**:
```python
response = openai.ChatCompletion.create(
    model="gpt-4o-mini",
    messages=st.session_state.messages
)

# 🔍 디버깅: 토큰 사용량 확인
usage = response['usage']
st.write(f"🔍 프롬프트 토큰: {usage['prompt_tokens']}")
st.write(f"🔍 응답 토큰: {usage['completion_tokens']}")
st.write(f"🔍 총 토큰: {usage['total_tokens']}")

# 대략적인 비용 계산 (GPT-3.5-turbo)
cost = (usage['prompt_tokens'] * 0.0015 +
        usage['completion_tokens'] * 0.002) / 1000
st.write(f"🔍 예상 비용: ${cost:.6f}")
```

**왜 messages 배열을 짧게 유지해야 하나?**:
- 대화가 길어지면 → 토큰 증가 → 비용 증가
- 해결책: 최근 10개 메시지만 유지하기

---

### Step 4: AI 비서 업그레이드 (1시간)

#### ✏️ 도전 과제 1: 전문가 모드

**AI에게 요청**:
```
사이드바에서 AI의 전문 분야를 선택할 수 있게 해줘.

옵션:
- 파이썬 선생님
- 영어 선생님
- 요리 전문가
- 여행 가이드

선택에 따라 system 프롬프트를 바꿔줘.
```

#### ✏️ 도전 과제 2: 대화 저장

**AI에게 요청**:
```
대화 내용을 텍스트 파일로 저장하는 기능을 추가해줘.

요구사항:
- 사이드바에 "대화 저장" 버튼
- 날짜와 시간이 포함된 파일명
- 대화 형식: "[나] 질문\n[AI] 답변\n"
```

#### ✏️ 도전 과제 3: Claude API 버전

**AI에게 요청**:
```
OpenAI 대신 Anthropic Claude API를 사용하는 버전으로 바꿔줘.

참고:
- pip install anthropic
- claude-3-haiku-20240307 모델 사용
- API 키는 st.secrets["ANTHROPIC_API_KEY"]
```

<details>
<summary><strong>💡 힌트: Claude API 기본 코드</strong></summary>

```python
import anthropic

client = anthropic.Anthropic(
    api_key=st.secrets["ANTHROPIC_API_KEY"]
)

message = client.messages.create(
    model="claude-3-haiku-20240307",
    max_tokens=1024,
    messages=[
        {"role": "user", "content": "안녕?"}
    ]
)

answer = message.content[0].text
```
</details>

---

### Step 5: 최종 기능 추가 (1시간)

#### ✏️ 도전 과제 4: 음성 입력 (난이도 ★★★)

**AI에게 요청**:
```
음성 인식 기능을 추가해줘.

요구사항:
- speech_recognition 라이브러리 사용
- 마이크 버튼 클릭하면 음성 인식 시작
- 인식된 텍스트를 채팅창에 자동 입력
```

#### ✏️ 도전 과제 5: 이미지 분석 (난이도 ★★★)

**AI에게 요청**:
```
이미지를 업로드하면 AI가 설명해주는 기능을 추가해줘.

요구사항:
- st.file_uploader로 이미지 업로드
- OpenAI Vision API 또는 Claude Vision 사용
- 이미지 내용을 자세히 설명
```

---

## 🌐 AI 챗봇 네트워크 공유 (선택사항, 10분)

### 친구와 AI 챗봇 공유하기

**네트워크 모드로 실행**:
```bash
streamlit run chatbot_app.py --server.address 0.0.0.0
```

**재미있는 시연**:

**시나리오 1: AI 역할극**
1. **A**: AI를 "영어 선생님"으로 설정
2. **B**: A의 챗봇 접속 → 영어 질문해보기
3. 각자 다른 전문가 모드로 설정해서 비교

**시나리오 2: 질문 대결**
1. 같은 질문을 각자의 챗봇에 물어보기
2. 누구의 챗봇이 더 좋은 답변을 하는지 비교
3. System 프롬프트를 바꿔서 다시 시도

**시나리오 3: 스마트폰 테스트**
1. 스마트폰으로 챗봇 접속
2. 이동하면서 AI와 대화
3. 반응형 디자인 확인

### 💡 주의사항

**API 비용**:
- 여러 사람이 동시 접속 → 토큰 사용량 증가
- 무료 크레딧 소진 주의!
- 테스트는 짧게!

**세션 독립성**:
- 각 접속자마다 독립적인 대화
- A의 대화는 B에게 안 보임
- 각자의 브라우저에 저장됨

---

## 🎓 3일차 학습 완료!

### ✅ 오늘 배운 것

**기술적 개념**:
1. **requests 라이브러리** - HTTP 요청, API 연동
2. **API 개념** - 외부 서비스 데이터 가져오기
3. **JSON 데이터** - 딕셔너리 형태의 데이터 처리
4. **OpenAI API** - GPT 모델 사용, 대화 생성
5. **Streamlit Secrets** - API KEY 안전 관리
6. **에러 처리** - try-except로 안정성 확보

**Streamlit 심화**:
- `st.secrets` - 비밀 정보 관리
- `st.chat_message()` - 채팅 메시지 UI
- `st.chat_input()` - 채팅 입력창
- `st.spinner()` - 로딩 애니메이션
- `st.sidebar` - 사이드바 위젯

### 🚀 만든 프로젝트

- ✅ 실시간 날씨 앱 (OpenWeatherMap API)
- ✅ AI 챗봇 (OpenAI/Claude API)

---

## 💡 4-5일차 프로젝트 준비

### 프로젝트 선택 기준

**제약 조건**:
- 화면 **1개** (Streamlit 페이지 1개)
- 배운 기술 **2가지 이상** 조합
- **4일차 오전까지 완성** 가능한 범위

### 추천 프로젝트 아이디어

| 프로젝트 | 사용 기술 | 난이도 | 설명 |
|---------|----------|--------|-----|
| **AI 일기장** | 파일저장 + AI | ★★☆ | 일기 쓰면 AI가 감정 분석 |
| **날씨 옷차림 추천** | 날씨API + AI | ★★☆ | 날씨보고 AI가 옷 추천 |
| **영어 회화 연습** | AI + 음성 | ★★★ | AI와 영어로 대화 연습 |
| **여행 플래너** | 지도API + AI | ★★☆ | AI가 여행 일정 추천 |
| **레시피 추천** | AI | ★☆☆ | 재료 말하면 요리법 추천 |
| **영화 추천 봇** | AI | ★☆☆ | 취향 분석해서 영화 추천 |
| **학습 도우미** | 파일 + AI | ★★☆ | 공부한 내용 정리하고 퀴즈 생성 |
| **번역 도우미** | AI | ★☆☆ | 실시간 다국어 번역 |

---

### 🤖 프로젝트별 SETUP 기반 AI 프롬프트

> **💡 핵심 전략**: 막연한 아이디어를 2단계 프롬프트로 구체화하세요!
> 1단계: 기본 MVP → 2단계: 핵심 기능 추가

---

#### 1️⃣ AI 일기장 (파일저장 + AI)

**📋 1단계: 기본 MVP (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: Streamlit으로 일기 작성 앱을 만들고 싶어요
- 목표: 일기를 작성하면 AI가 감정을 분석해주는 앱
- 입력: 사용자가 오늘의 일기를 텍스트로 입력
- 출력: 작성된 일기 + AI 감정 분석 결과 (긍정/부정/중립 + 이유)
- 제약사항: streamlit, openai 라이브러리만 사용
- 코드 스타일: 초보자가 이해하기 쉽게, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 AI 일기장을 만들어줘:
1. **일기 입력 영역**: st.text_area로 여러 줄 입력
2. **감정 분석 버튼**: 버튼 클릭 시 OpenAI API로 감정 분석
3. **분석 결과 표시**: 감정(긍정/부정/중립), 이유, 조언을 보기 좋게 표시
4. **파일 저장**: 일기와 분석 결과를 날짜별 txt 파일로 저장 (YYYY-MM-DD_diary.txt)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 과거 일기 보기 기능 추가 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 AI 일기장이 있어요
- 목표: 과거에 작성한 일기들을 날짜별로 볼 수 있게 하기
- 입력: 사이드바에서 날짜 선택
- 출력: 선택한 날짜의 일기와 감정 분석 결과
- 제약사항: 기존 코드에 추가, streamlit 사이드바 사용
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 AI 일기장에 다음 기능을 추가해줘:
1. **사이드바 날짜 선택**: st.sidebar.date_input으로 날짜 선택
2. **저장된 일기 목록**: 저장된 일기 파일 목록 표시
3. **과거 일기 불러오기**: 선택한 날짜의 txt 파일 읽어서 표시
4. **감정 통계**: 최근 7일간 긍정/부정/중립 비율을 st.metric으로 표시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 2️⃣ 날씨 옷차림 추천 (날씨API + AI)

**📋 1단계: 기본 날씨 + 옷차림 추천 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 날씨에 따라 옷차림을 추천받고 싶어요
- 목표: 도시의 날씨를 확인하고 AI가 적절한 옷차림 추천
- 입력: 도시 이름 입력
- 출력: 현재 날씨 정보 + AI의 옷차림 추천 (상의/하의/외투/악세서리)
- 제약사항: streamlit, requests, openai 사용
- 코드 스타일: 날씨 정보는 컬럼으로 깔끔하게, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 날씨 옷차림 추천 앱을 만들어줘:
1. **도시 입력**: st.text_input으로 도시명 입력
2. **날씨 확인 버튼**: OpenWeatherMap API로 온도, 체감온도, 날씨 가져오기
3. **날씨 표시**: 3개 컬럼으로 온도/체감온도/날씨 표시
4. **AI 옷차림 추천**: 날씨 정보를 OpenAI에 전달해서 옷차림 추천받기
5. **추천 결과 표시**: 상의/하의/외투/악세서리별로 구분해서 표시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 시간대별 추천 + 이미지 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 날씨 옷차림 추천 앱이 있어요
- 목표: 시간대별(아침/낮/저녁) 다른 추천 + 날씨 아이콘 이미지
- 입력: 사이드바에서 시간대 선택
- 출력: 시간대에 맞는 옷차림 추천 + 날씨 이모지/아이콘
- 제약사항: 기존 코드에 추가
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 날씨 옷차림 앱에 다음 기능을 추가해줘:
1. **시간대 선택**: st.sidebar.radio로 "아침/낮/저녁" 선택
2. **시간대별 추천**: 선택한 시간대를 AI에게 전달해서 다른 옷차림 추천
3. **날씨 이모지**: 날씨 상태(맑음/흐림/비/눈)에 따라 이모지 표시 (☀️/☁️/🌧️/❄️)
4. **추천 이유**: AI가 "왜 이 옷차림을 추천하는지" 한 줄 설명 추가
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 3️⃣ 영어 회화 연습 (AI + 음성) - ★★★

**📋 1단계: 텍스트 기반 영어 회화 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: AI와 영어로 대화 연습하고 싶어요
- 목표: AI 영어 선생님과 채팅하면서 문법/표현 교정받기
- 입력: 사용자가 영어로 메시지 입력
- 출력: AI의 영어 답변 + 문법 교정 + 더 나은 표현 제안
- 제약사항: streamlit, openai 사용, chat_message 사용
- 코드 스타일: 챗봇 UI, 교정 내용은 구분해서 표시, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 영어 회화 연습 앱을 만들어줘:
1. **채팅 UI**: st.chat_message로 대화 표시
2. **AI 역할 설정**: system 프롬프트로 "친절한 영어 선생님" 역할 부여
3. **대화 기능**: 사용자 영어 입력 → AI 영어 답변
4. **문법 교정**: 사용자 메시지에 문법 오류가 있으면 교정해서 별도 표시
5. **더 나은 표현**: "이렇게 말하면 더 자연스러워요" 제안
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 상황별 회화 연습 모드 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 영어 회화 앱이 있어요
- 목표: 상황별(카페 주문/공항/쇼핑) 역할극 모드 추가
- 입력: 사이드바에서 상황 선택
- 출력: 선택한 상황에 맞는 AI 역할 + 시작 멘트
- 제약사항: 기존 코드에 추가, 상황별로 system 프롬프트 변경
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 영어 회화 앱에 다음 기능을 추가해줘:
1. **상황 선택**: st.sidebar.selectbox로 "일상대화/카페 주문/공항 체크인/쇼핑" 선택
2. **역할극 시작**: 선택한 상황에 맞게 AI가 먼저 말 걸기
   - 카페 주문: "Hi! What can I get for you today?"
   - 공항: "May I see your passport and ticket?"
3. **상황별 교정**: 상황에 맞는 표현을 더 자세히 알려주기
4. **진행도 표시**: 대화 횟수를 st.sidebar에 표시 (10회 목표)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 4️⃣ 여행 플래너 (지도API + AI)

**📋 1단계: 여행지 추천 기본 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: AI에게 여행지 추천받고 싶어요
- 목표: 여행 조건을 입력하면 AI가 여행지와 일정 추천
- 입력: 여행 기간, 예산, 선호 활동(자연/문화/음식)
- 출력: 추천 여행지 3곳 + 각 여행지별 간단한 일정
- 제약사항: streamlit, openai 사용
- 코드 스타일: 입력은 사이드바, 결과는 탭으로 구분, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 여행 플래너 앱을 만들어줘:
1. **여행 조건 입력**: st.sidebar에서
   - 여행 기간: st.number_input (1-14일)
   - 예산: st.select_slider (50만원/100만원/200만원/300만원+)
   - 선호 활동: st.multiselect (자연/문화/음식/쇼핑/휴양)
2. **추천 요청 버튼**: 조건을 OpenAI에 전달
3. **여행지 추천**: AI가 조건에 맞는 여행지 3곳 추천
4. **탭으로 구분**: st.tabs로 여행지별 일정 표시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 상세 일정 + 지도 링크 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 여행 플래너가 있어요
- 목표: 선택한 여행지의 상세 일정 + 구글 지도 링크
- 입력: 사용자가 추천받은 여행지 중 하나 선택
- 출력: 일차별 상세 일정 + 각 장소의 구글 지도 링크
- 제약사항: 기존 코드에 추가
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 여행 플래너에 다음 기능을 추가해줘:
1. **여행지 선택**: 추천받은 3곳 중 하나를 st.radio로 선택
2. **상세 일정 생성**: 선택한 여행지의 일차별 상세 일정 (장소/시간/활동)
3. **구글 지도 링크**: 각 장소마다 구글 지도 링크 생성
   - 형식: https://www.google.com/maps/search/?api=1&query=장소명
4. **예상 비용**: 일정별 예상 비용 (숙박/식사/교통/입장료) 표시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 5️⃣ 레시피 추천 (AI)

**📋 1단계: 재료 기반 레시피 추천 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 집에 있는 재료로 요리 레시피를 추천받고 싶어요
- 목표: 재료를 입력하면 AI가 만들 수 있는 요리 추천
- 입력: 현재 가지고 있는 재료 목록
- 출력: 추천 요리 3가지 + 각 요리별 레시피 (재료/조리법/시간)
- 제약사항: streamlit, openai 사용
- 코드 스타일: 입력은 간단하게, 결과는 보기 좋게, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 레시피 추천 앱을 만들어줘:
1. **재료 입력**: st.text_area로 쉼표로 구분해서 재료 입력
   - 예: "계란, 파, 양파, 밥"
2. **추가 옵션**: st.sidebar에서
   - 조리 시간: st.slider (10분/20분/30분/1시간)
   - 난이도: st.radio (쉬움/보통/어려움)
3. **레시피 추천 버튼**: 재료와 옵션을 OpenAI에 전달
4. **요리 3가지 추천**: 각 요리마다 탭으로 구분
   - 요리명 + 이모지
   - 필요한 재료 (있는 것/없는 것 구분)
   - 조리 순서 (번호 매겨서)
   - 예상 조리 시간
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 영양 정보 + 저장 기능 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 레시피 추천 앱이 있어요
- 목표: 영양 정보 표시 + 마음에 드는 레시피 저장
- 입력: 추천받은 레시피 중 저장할 요리 선택
- 출력: 영양 정보 (칼로리/단백질/탄수화물/지방) + 저장된 레시피 목록
- 제약사항: 기존 코드에 추가
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 레시피 추천 앱에 다음 기능을 추가해줘:
1. **영양 정보**: 각 요리마다 대략적인 영양 정보 표시
   - st.columns로 칼로리/단백질/탄수화물/지방 4개 컬럼
2. **레시피 저장**: 마음에 드는 레시피를 "저장" 버튼으로 저장
   - JSON 파일에 저장 (saved_recipes.json)
3. **저장된 레시피**: 사이드바에 "내 레시피" 탭 추가
   - 저장된 레시피 목록 표시
   - 클릭하면 해당 레시피 불러오기
4. **별점 기능**: 레시피에 별점(1-5) 매길 수 있게 추가
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 6️⃣ 영화 추천 봇 (AI)

**📋 1단계: 취향 분석 영화 추천 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: AI에게 영화 추천받고 싶어요
- 목표: 내 취향을 분석해서 영화 추천받기
- 입력: 좋아하는 영화 3개, 선호 장르, 기분
- 출력: 추천 영화 5개 + 각 영화별 추천 이유
- 제약사항: streamlit, openai 사용
- 코드 스타일: 입력은 사이드바, 결과는 카드 형태, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 영화 추천 봇을 만들어줘:
1. **취향 입력**: st.sidebar에서
   - 좋아하는 영화: st.text_area (3개 이상)
   - 선호 장르: st.multiselect (액션/로맨스/코미디/스릴러/SF/드라마)
   - 오늘 기분: st.select_slider (우울함/보통/신남)
2. **추천 요청**: OpenAI에 취향 정보 전달
3. **영화 5개 추천**: 각 영화마다
   - 영화 제목 + 개봉연도
   - 장르
   - 한 줄 요약
   - 추천 이유 (내 취향과 어떻게 맞는지)
4. **카드 UI**: st.container로 영화별 카드 형태 표시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 챗봇 모드 + 시청 기록 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 영화 추천 봇이 있어요
- 목표: 대화하면서 추천받기 + 본 영화 기록
- 입력: 챗봇으로 자유롭게 대화
- 출력: AI와 대화하면서 영화 추천 + 시청 기록 관리
- 제약사항: 기존 코드에 추가, chat_message 사용
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 영화 추천 봇에 다음 기능을 추가해줘:
1. **챗봇 모드**: st.chat_message로 대화 형식 추가
   - "어떤 영화 찾으세요?" → 자연스러운 대화로 추천
2. **시청 완료 체크**: 추천받은 영화를 "봤어요" 버튼으로 체크
   - JSON 파일에 시청 기록 저장 (watched_movies.json)
3. **시청 기록**: 사이드바에 "본 영화" 목록 표시
   - 영화 제목 + 시청 날짜
   - 별점 매기기 (1-5)
4. **맞춤 추천 개선**: 시청 기록을 바탕으로 더 정확한 추천
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 7️⃣ 학습 도우미 (파일 + AI)

**📋 1단계: 학습 내용 정리 + 퀴즈 생성 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 공부한 내용을 정리하고 퀴즈로 복습하고 싶어요
- 목표: 학습 내용을 입력하면 AI가 요약 + 퀴즈 생성
- 입력: 오늘 공부한 내용 (텍스트 또는 파일)
- 출력: 3줄 요약 + 핵심 개념 + 퀴즈 5문제
- 제약사항: streamlit, openai 사용
- 코드 스타일: 요약과 퀴즈를 탭으로 구분, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 학습 도우미 앱을 만들어줘:
1. **학습 내용 입력**:
   - st.text_area로 직접 입력 또는
   - st.file_uploader로 txt 파일 업로드
2. **AI 분석 버튼**: 학습 내용을 OpenAI에 전달
3. **3줄 요약**: 핵심 내용을 3줄로 요약
4. **핵심 개념**: 주요 개념 5개를 불릿 포인트로 정리
5. **퀴즈 생성**: 객관식 5문제 생성 (각 문제마다 4개 선택지)
6. **퀴즈 풀기**: st.radio로 답 선택 → "정답 확인" 버튼
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 학습 기록 + 복습 알림 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 학습 도우미가 있어요
- 목표: 학습 기록 저장 + 복습 주기 관리
- 입력: 저장된 학습 내용
- 출력: 날짜별 학습 기록 + 복습이 필요한 내용 알림
- 제약사항: 기존 코드에 추가, JSON 파일로 저장
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 학습 도우미에 다음 기능을 추가해줘:
1. **학습 기록 저장**:
   - 날짜, 주제, 요약, 퀴즈 결과를 JSON에 저장
   - 파일명: study_history.json
2. **학습 달력**: 사이드바에 날짜별 학습 기록 표시
   - st.date_input으로 날짜 선택
   - 해당 날짜의 학습 내용 불러오기
3. **복습 알림**: 에빙하우스 망각곡선 적용
   - 1일 후, 7일 후, 30일 후 복습 필요
   - 복습이 필요한 내용을 st.warning으로 표시
4. **학습 통계**:
   - 총 학습 일수
   - 평균 퀴즈 정답률
   - 복습 완료율
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

#### 8️⃣ 번역 도우미 (AI)

**📋 1단계: 다국어 번역 기본 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: AI로 실시간 다국어 번역을 하고 싶어요
- 목표: 텍스트를 입력하면 선택한 언어로 번역
- 입력: 원문 텍스트 + 목표 언어 선택
- 출력: 번역 결과 + 발음 (필요시)
- 제약사항: streamlit, openai 사용
- 코드 스타일: 입력과 출력을 나란히 배치, 주석은 한글로

[YOUR TASK]
다음 기능을 가진 번역 도우미 앱을 만들어줘:
1. **언어 선택**: st.columns로 2열 배치
   - 왼쪽: 원문 언어 (자동 감지 또는 선택)
   - 오른쪽: 번역 언어 (영어/일본어/중국어/스페인어/프랑스어)
2. **텍스트 입력**: st.text_area로 여러 줄 입력 가능
3. **번역 버튼**: OpenAI에 번역 요청
4. **번역 결과**:
   - 번역된 텍스트
   - 발음 (일본어/중국어의 경우)
   - 원문 언어 자동 감지 결과
5. **복사 버튼**: 번역 결과를 클립보드에 복사
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**📋 2단계: 문맥 설명 + 대화 번역 (복사-붙여넣기 프롬프트)**

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[SETUP]
- 상황: 위에서 만든 번역 도우미가 있어요
- 목표: 번역뿐 아니라 문맥 설명 + 실시간 대화 번역
- 입력: 원문 텍스트 또는 대화
- 출력: 번역 + 문맥 설명 + 비슷한 표현들
- 제약사항: 기존 코드에 추가
- 코드 스타일: 기존 스타일 유지, 주석은 한글로

[YOUR TASK]
현재 번역 도우미에 다음 기능을 추가해줘:
1. **번역 모드 선택**: st.sidebar.radio
   - "일반 번역": 단순 번역만
   - "문맥 번역": 번역 + 문맥 설명 + 비슷한 표현 3가지
   - "대화 번역": 실시간 대화 번역 (채팅 형식)
2. **문맥 설명**: "문맥 번역" 모드일 때
   - 번역 결과
   - 이 표현을 왜 이렇게 번역했는지 설명
   - 비슷한 표현 3가지 + 뉘앙스 차이
3. **대화 번역**: "대화 번역" 모드일 때
   - st.chat_message로 대화 형식
   - 입력하면 즉시 번역해서 표시
   - 양방향 번역 (한→영, 영→한)
4. **번역 히스토리**: 사이드바에 최근 번역 5개 표시
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

### 💡 프롬프트 사용 방법

**Step 1**: 위에서 만들고 싶은 프로젝트 선택
**Step 2**: 1단계 프롬프트 전체를 복사해서 AI(ChatGPT/Claude)에게 붙여넣기
**Step 3**: AI가 만든 코드를 실행하고 테스트
**Step 4**: 작동하면 2단계 프롬프트로 기능 추가

**핵심 포인트**:
- 박스 전체(`━━━` 포함)를 복사하세요
- SETUP 부분이 AI에게 명확한 지시를 줍니다
- 문제가 있으면 "이 부분이 안 되는데, 어떻게 고치지?" 추가 질문

---

### AI 활용 프롬프트 (아이디어 구체화)

**기능 분석**:
```
"[아이디어]를 구현하기 위해 필요한 기능을 단계별로 나열해줘"

"[아이디어]에서 가장 핵심이 되는 기능 3가지는 뭘까?"

"[아이디어]를 4시간 안에 완성하려면 어떤 순서로 작업해야 할까?"
```

**화면 설계**:
```
"[아이디어]의 화면 레이아웃을 텍스트로 설명해줘"

"[아이디어]에 어울리는 색상과 이모지를 추천해줘"

"사용자가 가장 먼저 보게 될 화면을 디자인해줘"
```

**기술 선택**:
```
"[아이디어]를 구현할 때 발생할 수 있는 기술적 어려움과 해결 방법을 알려줘"

"비슷한 프로젝트의 예제 코드 구조를 보여줘"

"[아이디어]에 필요한 API나 라이브러리를 추천해줘"
```

### MVP(최소 기능 제품) 접근법

**1단계: 핵심 기능만**
```
예: AI 일기장
✅ 일기 입력
✅ AI 감정 분석
❌ 통계 차트 (나중에)
❌ 일기 검색 (나중에)
```

**2단계: 시간 계획**
```
09:00-10:00  기획 및 화면 설계
10:00-12:00  핵심 기능 구현
13:00-15:00  AI 연동 및 테스트
15:00-16:00  디자인 개선
```

**3단계: AI와 협업**
```
"이 프로젝트의 MVP로 먼저 만들 핵심 기능은 무엇일까?"

"4시간 안에 완성 가능한 범위로 기능을 축소해줘"

"단계별로 테스트하면서 만들 수 있게 작업을 나눠줘"
```

---

## 🎯 내일 할 일

### 4일차 오전 (09:00-12:00)
- 아이디어 최종 결정
- AI와 함께 기능 구현
- 핵심 기능 완성

### 4일차 오후 (13:00-16:00)
- 디자인 개선
- 에러 처리 추가
- 테스트 및 마무리

### 5일차 (09:00-16:00)
- 프로젝트 완성
- 발표 준비
- 발표 및 피드백

---

## 📚 참고 자료

### API 문서
- OpenWeatherMap: https://openweathermap.org/api
- OpenAI: https://platform.openai.com/docs
- Anthropic Claude: https://docs.anthropic.com/
- 카카오 지도: https://developers.kakao.com/

### Streamlit 문서
- Secrets 관리: https://docs.streamlit.io/library/advanced-features/secrets-management
- Chat 요소: https://docs.streamlit.io/library/api-reference/chat

### 추가 학습
- requests 문서: https://requests.readthedocs.io/
- JSON 다루기: https://docs.python.org/ko/3/library/json.html

---

**화이팅! 내일은 여러분만의 프로젝트를 완성하는 날입니다! 🚀**

---

**작성자**: 파이썬사랑방 이진석
**마지막 업데이트**: 2025-10-09
