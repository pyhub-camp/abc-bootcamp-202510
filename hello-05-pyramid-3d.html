<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D 피라미드 출력기</title>
  <style>
    :root{--bg:#0b1020;--panel:#121935;--text:#e9ecff;--muted:#9aa4d6;--accent:#71a9ff}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b1020,#0e1430);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR,Apple Color Emoji,Segoe UI Emoji;display:grid;grid-template-rows:auto 1fr auto}
    header,footer{display:flex;gap:10px;align-items:center;padding:12px 16px;border-bottom:1px solid #1b2347}
    footer{border:0;border-top:1px solid #1b2347;color:var(--muted);font-size:12px;justify-content:space-between;flex-wrap:wrap}
    .title{font-weight:700}
    .wrap{display:grid;grid-template-columns:320px 1fr;gap:14px;padding:14px}
    @media (max-width:960px){.wrap{grid-template-columns:1fr}}
    .panel{background:var(--panel);border:1px solid #202a55;border-radius:16px;box-shadow:0 10px 30px #0008}
    .controls{padding:14px;display:grid;gap:12px}
    label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
    input[type=number],select{width:100%;border:1px solid #2a3670;background:#0f1633;color:var(--text);padding:10px 12px;border-radius:10px;font-size:14px;outline:none}
    input[type=number]:focus,select:focus{border-color:var(--accent);box-shadow:0 0 0 3px #6ea8fe33}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    button{background:linear-gradient(180deg,#7ab1ff,#538eff);border:none;color:#0a1025;font-weight:800;padding:10px 12px;border-radius:10px;cursor:pointer}
    .ghost{background:#0f1633;color:var(--text);border:1px solid #2a3670}
    .tiny{font-size:12px;color:var(--muted)}
    .canvas-panel{position:relative;min-height:420px}
    #scene{position:absolute;inset:0;border-radius:16px;overflow:hidden}
    .hint{position:absolute;left:10px;bottom:10px;background:#0f1633cc;border:1px solid #2a3670;color:var(--text);padding:6px 8px;border-radius:8px;font-size:12px}
  </style>
</head>
<body>
  <header>
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 4l8 16H4L12 4Z" stroke="#71a9ff" stroke-width="1.5" stroke-linejoin="round"/></svg>
    <div class="title">3D 피라미드 출력기</div>
    <span class="tiny" style="margin-left:auto">모드: left • center(기본) • right • diamond</span>
  </header>
  <main class="wrap">
    <section class="panel controls" aria-labelledby="ctl-title">
      <h2 id="ctl-title" style="margin:0;font-size:14px;color:var(--muted)">설정</h2>
      <div>
        <label for="height">높이 (1~50)</label>
        <input id="height" type="number" min="1" max="50" step="1" placeholder="예: 8" value="6" />
      </div>
      <div>
        <label for="mode">모드</label>
        <select id="mode">
          <option value="center" selected>center (중앙)</option>
          <option value="left">left (좌측)</option>
          <option value="right">right (우측)</option>
          <option value="diamond">diamond (마름모)</option>
        </select>
      </div>
      <div class="row">
        <button id="build">출력/갱신</button>
        <button id="reset" class="ghost" title="카메라 초기화">카메라 리셋</button>
      </div>
      <div class="row">
        <label style="display:flex;align-items:center;gap:8px"><input id="gridToggle" type="checkbox" checked/> 격자 보이기</label>
        <label style="display:flex;align-items:center;gap:8px"><input id="shadowToggle" type="checkbox" checked/> 그림자</label>
      </div>
      <div>
        <label for="scale">큐브 크기 (0.6~1.6)</label>
        <input id="scale" type="range" min="0.6" max="1.6" step="0.1" value="1" />
      </div>
      <p class="tiny">Tip: 마우스로 드래그하여 회전, 스크롤로 줌, 우클릭으로 이동합니다.</p>
    </section>

    <section class="panel canvas-panel" aria-label="3D 장면">
      <div id="scene"></div>
      <div class="hint">⟲ 드래그로 회전 • ⌘/Ctrl + 스크롤로 줌</div>
    </section>
  </main>
  <footer>
    <span>Three.js로 구성된 실시간 3D • 많은 블록은 성능에 영향을 줄 수 있어 높이를 50으로 제한했습니다.</span>
    <span>© 2025 Pyramid Builder • Shadows & PBR</span>
  </footer>

  <!-- 3D: ES Modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.161.0/build/three.module.js"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // --- DOM ---
    const container = document.getElementById('scene');
    const heightEl = document.getElementById('height');
    const modeEl = document.getElementById('mode');
    const gridToggle = document.getElementById('gridToggle');
    const shadowToggle = document.getElementById('shadowToggle');
    const buildBtn = document.getElementById('build');
    const resetBtn = document.getElementById('reset');
    const scaleEl = document.getElementById('scale');

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // --- Scene & Camera ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b1020);

    const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(12, 14, 20);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // --- Lights ---
    const hemi = new THREE.HemisphereLight(0xaabbff, 0x223366, 0.6);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(10, 18, 8);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.near = 1; dir.shadow.camera.far = 60;
    scene.add(dir);

    // --- Ground ---
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x0f1633, metalness: 0.1, roughness: 0.9 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.receiveShadow = true;
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.01;
    scene.add(ground);

    // Grid helper (toggle)
    const grid = new THREE.GridHelper(200, 200, 0x29407a, 0x1b2b55);
    grid.material.opacity = 0.35; grid.material.transparent = true;
    scene.add(grid);

    // --- Pyramid Group ---
    let pyramidGroup = new THREE.Group();
    scene.add(pyramidGroup);

    // Materials
    const baseColor = new THREE.Color('#6ea8fe');
    const material = new THREE.MeshStandardMaterial({ color: baseColor, metalness: 0.25, roughness: 0.35 });

    // Geometry cache by scale
    const geomCache = new Map();
    function getCubeGeometry(scale=1){
      const key = scale.toFixed(1);
      if (!geomCache.has(key)) {
        geomCache.set(key, new THREE.BoxGeometry(scale, scale, scale));
      }
      return geomCache.get(key);
    }

    // Compute block positions based on text pattern logic
    function computePositions(n, mode){
      const positions = []; // {x,z}
      const addRow = (width, offsetX, rowIndex) => {
        for (let k = 0; k < width; k++) positions.push({ x: offsetX + k, z: rowIndex });
      };

      if (mode === 'left'){
        for (let i=1;i<=n;i++) addRow(i, 0, i-1);
      } else if (mode === 'right'){
        for (let i=1;i<=n;i++) addRow(i, n - i, i-1);
      } else if (mode === 'diamond'){
        let row=0;
        for (let i=1;i<=n;i++,row++) addRow(2*i-1, n - i, row);
        for (let i=n-1;i>=1;i--,row++) addRow(2*i-1, n - i, row);
      } else { // center
        for (let i=1;i<=n;i++) addRow(2*i-1, n - i, i-1);
      }

      // Center to origin
      let minX=Infinity,maxX=-Infinity,minZ=Infinity,maxZ=-Infinity;
      for (const p of positions){
        if (p.x<minX) minX=p.x; if (p.x>maxX) maxX=p.x; if (p.z<minZ) minZ=p.z; if (p.z>maxZ) maxZ=p.z;
      }
      const cx = (minX + maxX) / 2;
      const cz = (minZ + maxZ) / 2;
      for (const p of positions){ p.x -= cx; p.z -= cz; }
      return positions;
    }

    function rebuild(){
      const n = Math.max(1, Math.min(50, parseInt(heightEl.value||'0',10)));
      const mode = modeEl.value || 'center';
      const scale = parseFloat(scaleEl.value)||1;

      // cleanup previous
      scene.remove(pyramidGroup);
      pyramidGroup.traverse(obj=>{ if (obj.isMesh){ obj.geometry.dispose(); obj.material.dispose?.(); }});
      pyramidGroup = new THREE.Group();

      const unit = 1.05 * scale; // spacing with a tiny gap
      const geom = getCubeGeometry(scale);

      const positions = computePositions(n, mode);

      // Height stacking: make a rising slope so it feels 3D pyramid-ish
      // For center/diamond we pile less height towards edges; for left/right, height = row index
      const topHeight = Math.max(1, Math.round(n * 0.6));

      for (const {x,z} of positions){
        let h = 1;
        if (mode === 'left' || mode === 'right') {
          // height increases with row (z) for a ramp feel
          h = 1 + Math.floor((Math.abs(z) + 1) * 0.2);
        } else {
          // center/diamond: higher near center axis
          const d = Math.abs(x);
          h = Math.max(1, topHeight - Math.floor(d));
        }
        for (let y=0; y<h; y++){
          const mesh = new THREE.Mesh(geom, material.clone());
          mesh.castShadow = true; mesh.receiveShadow = true;
          mesh.position.set(x*unit, (y*scale) + scale/2, z*unit);
          // Slight hue variation by position for depth
          const hueShift = ( (x+z)*7 % 360 ) / 360;
          const c = new THREE.Color().setHSL(0.6 + 0.05*hueShift, 0.6, 0.6);
          mesh.material.color = c;
          pyramidGroup.add(mesh);
        }
      }

      scene.add(pyramidGroup);

      // Fit camera to new bounds
      fitView(pyramidGroup, 1.4);
    }

    function fitView(target, pad=1.3){
      const box = new THREE.Box3().setFromObject(target);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size); box.getCenter(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI/180);
      let dist = maxDim / (2 * Math.tan(fov/2));
      dist *= pad; // padding
      const dir = new THREE.Vector3(1, 1, 1).normalize();
      camera.position.copy(center.clone().add(dir.multiplyScalar(dist)));
      camera.near = Math.max(0.1, dist/100);
      camera.far = dist*10 + 100;
      camera.lookAt(center);
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    // UI handlers
    buildBtn.addEventListener('click', rebuild);
    [modeEl, heightEl, scaleEl].forEach(el=> el.addEventListener('change', rebuild));
    resetBtn.addEventListener('click', ()=> fitView(pyramidGroup, 1.2));
    gridToggle.addEventListener('change', ()=> grid.visible = gridToggle.checked);
    shadowToggle.addEventListener('change', ()=> { renderer.shadowMap.enabled = shadowToggle.checked; });

    // Resize
    const resize = ()=>{
      const {clientWidth:w, clientHeight:h} = container;
      renderer.setSize(w, h);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    };
    window.addEventListener('resize', resize);

    // Animate
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      dir.position.x = Math.cos(t*0.3)*14; dir.position.z = Math.sin(t*0.3)*12; dir.position.y = 12 + Math.sin(t*0.7)*2;
      controls.update();
      renderer.render(scene, camera);
    }

    // First build
    resize();
    rebuild();
    animate();
  </script>
</body>
</html>
