# factorial.py 문법 설명

이 문서는 `factorial.py` 파일에서 사용한 파이썬 문법을 한 줄씩 따라가며 설명합니다. 파이썬을 처음 접한다고 가정하고 아주 기본부터 풀이합니다.

## 파일 머리말과 문서 문자열

- `#!/usr/bin/env python3`  
  리눅스나 맥에서 이 스크립트를 바로 실행할 때, 어떤 파이썬 인터프리터를 쓸지 알려주는 특별한 주석입니다. 윈도우에서는 크게 영향이 없습니다.
- `""" ... """` (파일 첫 부분과 함수 안에 있음)  
  큰따옴표 3개로 둘러싼 문자열은 *문서 문자열(docstring)* 이라고 합니다. 파일이나 함수가 무엇을 하는지 설명하는 글을 적습니다. 프로그램이 실행될 때도 존재하는 실제 문자열이지만, 주석처럼 설명용으로 사용합니다.

## 모듈 가져오기

- `from __future__ import annotations`  
  파이썬의 미래 기능을 미리 사용하겠다는 선언입니다. 여기서는 타입 힌트를 더 편하게 쓰기 위해 가져옵니다.
- `import argparse` 와 `import sys`  
  다른 파일(모듈)에 들어 있는 기능을 가져오는 문법입니다. `argparse` 는 명령줄 옵션을 읽어 주고, `sys` 는 파이썬 실행 환경과 관련된 기능을 제공합니다.

## 함수 정의와 타입 힌트

- `def factorial(n: int) -> int:`  
  `def` 로 함수를 정의합니다. 괄호 안의 `n: int` 는 *타입 힌트* 로, `n` 이 정수여야 한다는 뜻입니다. `-> int` 는 이 함수가 정수를 돌려준다고 알려줍니다. 타입 힌트는 설명용이지만, 에디터가 오류를 미리 보여 주는 데 도움을 줍니다.
- 들여쓰기(스페이스 4칸)  
  파이썬에서는 공백으로 블록을 나눕니다. 함수 안에 들어가는 모든 줄은 들여쓰기 해야 합니다.
- 함수 안의 `"""Return n! ..."""`  
  함수 전용 문서 문자열입니다. 이 함수가 하는 일을 설명합니다.

## 조건문과 예외

- `if not isinstance(n, int):`  
  `if` 는 조건문입니다. `not` 은 조건의 참/거짓을 뒤집습니다. `isinstance(n, int)` 는 `n` 이 정수인지 검사합니다.
- `raise TypeError("n must be an integer")`  
  `raise` 는 문제 상황(예외)을 직접 발생시킵니다. `TypeError` 는 "자료형이 잘못되었다"는 표준 예외입니다.
- `if n < 0:` 과 `raise ValueError(...)`  
  다른 조건을 검사하고, 조건을 만족하면 또 다른 예외를 발생시킵니다. `ValueError` 는 값이 잘못되었을 때 씁니다.

## 변수와 반복문

- `result = 1`  
  변수를 만들고 값을 넣는 가장 기본적인 문법입니다.
- `for i in range(2, n + 1):`  
  `for` 반복문은 여러 값을 차례대로 꺼내서 `i` 에 집어넣고, 반복 실행합니다. `range(2, n + 1)` 은 2부터 `n` 까지의 정수를 만들어 줍니다. `n + 1` 을 하는 이유는 파이썬의 `range` 가 끝 숫자 직전까지만 포함하기 때문입니다.
- `result *= i`  
  `result = result * i` 를 짧게 쓴 문법입니다. 다른 연산(`+=`, `-=`, `/=` 등)도 같은 방식으로 쓸 수 있습니다.
- `return result`  
  함수가 종료되면서 결과값을 돌려줍니다.

## 주 함수(main)와 기본값

- `def main(argv: list[str] | None = None) -> int:`  
  또 다른 함수를 정의합니다. `argv` 매개변수에는 기본값으로 `None` 을 넣었습니다. 즉, 값을 넘기지 않으면 `None` 이 됩니다. `list[str] | None` 은 "문자열 리스트 또는 `None` 둘 중 하나" 라는 뜻입니다. `|` 기호는 두 타입의 *합집합(union)* 을 표현합니다.

## 객체 만들기와 메서드 호출

- `parser = argparse.ArgumentParser(...)`  
  `argparse` 모듈 안의 `ArgumentParser` 클래스로 객체(인스턴스)를 만듭니다. 괄호 안에는 생성자에게 넘겨줄 설정을 적습니다.
- `parser.add_argument("n", nargs="?", type=int, help="...")`  
  `.` 뒤에 붙는 `add_argument` 는 `parser` 객체가 가진 *메서드* 입니다. 명령줄에서 받을 값을 정의합니다. `"n"` 은 인자 이름, `nargs="?"` 는 선택적으로 받을 수 있다는 뜻, `type=int` 는 자동으로 정수로 바꿔 달라는 뜻입니다.
- `args = parser.parse_args(argv)`  
  입력을 실제로 해석해서 결과를 `args` 에 저장합니다. `args` 는 속성 접근(`args.n`) 으로 값을 읽을 수 있는 객체입니다.

## `None` 검사와 입력 받기

- `if args.n is None:`  
  `is` 는 객체가 완전히 같은지 비교합니다. `None` 은 "값이 없음"을 표현하는 특별한 객체라 `==` 대신 `is` 를 씁니다.
- `try:` … `except EOFError:`  
  오류가 날 수 있는 코드를 `try` 블록에 넣고, 문제가 생기면 `except` 블록이 실행됩니다. `EOFError` 는 입력이 갑자기 끝났을 때 발생하는 예외입니다.
- `raw = input("...").strip()`  
  `input()` 은 사용자에게서 문자열을 받습니다. 뒤에 `.strip()` 을 붙이면 앞뒤 공백을 제거해 줍니다.
- `if raw == "":`  
  빈 문자열인지 비교합니다. 문자열은 작은따옴표나 큰따옴표 아무거나 써도 됩니다.
- `n = int(raw)` 와 `except ValueError:`  
  `int()` 함수로 문자열을 정수로 바꿉니다. 정수로 바꿀 수 없는 문자열이라면 `ValueError` 가 발생하므로 바로 아래 `except ValueError:` 가 그것을 처리합니다.
- `else:`  
  `if` 와 같은 들여쓰기 단계에서 사용합니다. `if` 조건이 거짓일 때 실행할 코드를 넣습니다.

## 함수 호출과 다중 예외 처리

- `value = factorial(n)`  
  앞에서 정의한 `factorial` 함수를 호출합니다. 괄호 안에 인수를 넣습니다.
- `except (TypeError, ValueError) as e:`  
  괄호로 예외 클래스를 묶으면 여러 종류의 예외를 한 번에 처리할 수 있습니다. `as e` 는 발생한 예외 객체를 `e` 라는 이름으로 받습니다.
- `print(f"Error: {e}", file=sys.stderr)`  
  `f"..."` 는 *포매팅 문자열(f-string)* 입니다. 중괄호 `{}` 안에 변수나 표현식을 넣어 문자열 안에 끼워 넣을 수 있습니다. `file=sys.stderr` 는 출력 위치를 표준 에러 스트림으로 바꾸는 키워드 인수입니다.
- `print(value)`  
  기본 출력(표준 출력)으로 값을 보냅니다.
- `return 0`  
  함수가 성공적으로 끝났음을 알리기 위해 `0` 을 반환합니다. 관례적으로 0은 성공, 0이 아닌 값은 실패를 의미합니다.

## 스크립트 직접 실행 여부 확인

- `if __name__ == "__main__":`  
  이 파일이 "직접 실행" 되었을 때만 아래 코드를 실행하라는 뜻입니다. 다른 파일이 이 모듈을 가져와서(import) 쓸 때는 실행되지 않습니다.
- `sys.exit(main())`  
  `main()` 함수를 호출해서 나온 숫자를 운영체제에 돌려줍니다. 실패했을 때 `2` 를 반환하므로, 운영체제도 그 값을 알 수 있게 됩니다.

## 추가로 알아두면 좋은 기본 문법

- 모든 코드 블록(`if`, `for`, `def` 등)은 끝에 콜론(`:`)을 붙이고, 다음 줄부터 들여쓰기 합니다.
- `#` 으로 시작하는 줄은 한 줄 주석입니다. 이 파일에서는 쓰지 않았지만, 자주 만나게 됩니다.
- 문자열은 `'` 또는 `"` 로 감싸서 만듭니다. 여러 줄 문자열이 필요하면 `"""` 또는 `'''` 를 사용합니다.
- 파이썬은 들여쓰기와 콜론으로 코드 구조를 표현하므로, 들여쓰기를 항상 일정하게 유지해야 합니다.
